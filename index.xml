<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>笔记</title>
    <link>https://blog.explosion.zip/</link>
    <description>Recent content on 笔记</description>
    <image>
      <url>https://blog.explosion.zip/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.explosion.zip/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 28 Dec 2022 11:21:05 +0800</lastBuildDate><atom:link href="https://blog.explosion.zip/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Telepresence踩坑</title>
      <link>https://blog.explosion.zip/posts/telepresence%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Wed, 28 Dec 2022 11:21:05 +0800</pubDate>
      
      <guid>https://blog.explosion.zip/posts/telepresence%E8%B8%A9%E5%9D%91/</guid>
      <description>telepresence 踩坑 telepresence 用法  k8s pod IP 由 CNI 分配, 通信是走 overlay 网络, 容器之间的通信都是基于cluser IP.[1]
 k8s的软件调试出了名的难搞,如果遇到日志设计不合理/不熟悉的代码,能打断点总是.没错,这就是我使用telepresence点初衷&amp;ndash; telepresence可以让本机接入k8s的overlay网络的同时,通过sidecar的方式拦截具体pod的流量转发到执行intercept的本地环境.
troublneshooting  无法建立和k8s内容器的链接/dns解析容器内部域名·失败
调试环境建立起来后,简单测试: curl -ik https://kubernetes.default, 返回一串json,表明成功解析了k8s的域名. 调试程序时,我执行curl去访问etcd.dev.svc.cluster.local这样自己搭建的资源时,却报错无法解析相应的dns,同时发现nslookup也无法解析.  在我的使用环境archlinux下,telepresence想要将k8s上服务的流量拦截到用户本机上,需要建立一个名为tel0的tun设备,这样本机就可以请求到k8s中服务的ip.但是光能链接ip不行,还需要让k8s内部的dns服务提供给用户的开发机,只有这样用户调试的软件才能和k8s集群内其他服务互通有无.
但是这里遇到的一个问题: /etc/resolv.conf不归属用户.我甚至使用sudo的权限删除了这个文件,但是还是被软件立马创建了出来.在一些文章中,这种情况被描述为一些服务把持着这个文件,阻止用户删除,甚至出现了数款服务互相争夺dns控制权互相覆写乃至于出现了dns中断的情况. 我的情况稍微简单,cat /etc/resolv.conf,观察到这样的内容:
# Generated by dhcpcd from ens33.dhcp # /etc/resolv.conf.head can replace this line domain AirDream nameserver 114.114.114.114 # /etc/resolv.conf.tail can replace this line 文件描述其被dhcpcd生成,查询资料,可以通过修改配置解除自动的文件生成. 即: 在/etc/dhcpcd.conf中添加nohook resolv.conf配置. 如果文件没有描述其被哪个文件生成,那就要辛辛苦苦的去排查了. 然后执行  ln -sf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf,让systemd-resolved生效. 如果 /run/systemd/resolve/stub-resolv.conf 之前被dhcp服务修改了,重启systemd—resolved就行.</description>
    </item>
    
    <item>
      <title>Solana合约开发指北</title>
      <link>https://blog.explosion.zip/posts/solana%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%8C%87%E5%8C%97/</link>
      <pubDate>Tue, 30 Aug 2022 13:22:27 +0800</pubDate>
      
      <guid>https://blog.explosion.zip/posts/solana%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%8C%87%E5%8C%97/</guid>
      <description>Solana合约开发指北 这里假定solana需要的开发环境: rust/node.js甚至Solana客户端都已经装好了.
合约是什么?简单来说,就是在提供多个函数rpc调用后,用户输入符合特定需求的结构体数据后,获得预期的结果或者符合规则的错误.同时提供在可接受的复杂度范围内,存储少量有关用户的元数据.
 On Solana, smart contracts are called programs
 首先,先确定solana的相关术语.为了符合官方的称谓,solana上的智能合约都被称作programs而非smart contracts.
随后,我们预想一个智能能合约案例,来展开描述在solana上开发智能合约要处理哪些细节.
Example Escrow Alice持有token X, Bob持有token Y,他们互相之间达成了交易约定: Alice 支付100X,和Bob手里50Y进行兑换.和我们购物使用淘宝一样,Alice和Bob都害怕交钱不发,所以需要一个能充当支付宝的智能合作作为一个可信赖的第三方托管,这就是我们案例: Escrow.
直观的去想,让Alice发起交易的时候转账给合约就行,让Bob后续去找合约拿钱.但这是传统支付宝的做法:支付宝拥有一个巨大的数据库,可以通过键值的方式记录下不同数以亿计的用户的交易对.在solana上,智能合约的数据存储是通过account来实现的,而每一个account最多只能提供32KB的数据存储,无法存储跟合约无关的用户数据.
solana并不是没有预见到这点,其提供的PDA(程序委托账户)能代我们做到记录无限的数据账户&amp;ndash;当用户与合约交易时,为其生成专属的account来存储交易细节.当Alice和智能合约互动的时候, 智能合约通过确定的种子生成一个PDA账户来处理这笔交易.
graph LR: Alice -&amp;gt; 让我们展开,一点点的捋下实现细节.
Setting up the project 我们可以参照这个案例创建一个rust的项目,我们修改Cargo.toml,让其知道我们需要的依赖和编译结果产出.
[package] name = &amp;#34;solana-escrow&amp;#34; version = &amp;#34;0.1.0&amp;#34; edition = &amp;#34;2021&amp;#34; license = &amp;#34;WTFPL&amp;#34; publish = false [dependencies] solana-program = &amp;#34;1.9.4&amp;#34; [lib] crate-type = [&amp;#34;cdylib&amp;#34;, &amp;#34;lib&amp;#34;] entrypoint.rs, program, and accounts 现在我们已经在着手编写这个智能合约了!如我们所见,最后编译成eBPF的程序,入口处在lib.rs中,我们通过use来引入任何被导入的函数,通过entrypoint!这个宏来定义process_instruction函数.这是唯一调用智能合约的方法,所有的合约调用都是通过entrypoint来触发.
 被调用的时候, program被传递给BPF Loader.</description>
    </item>
    
    <item>
      <title>Rust Pin Unpin</title>
      <link>https://blog.explosion.zip/posts/rust-pin-unpin/</link>
      <pubDate>Sat, 31 Oct 2020 10:03:02 +0800</pubDate>
      
      <guid>https://blog.explosion.zip/posts/rust-pin-unpin/</guid>
      <description>rust的Pin指针 pin指针是一个在销毁前永远不会移动的指针。配合该指针可以更让结构体中包含指向它自己内存的指针&amp;ndash;因为移动了后结构体中的这个指针就会变成悬垂引用，这就与rust安全的设计相冲突。也就是说，声明pin指针就是创建一个在生命周期结束前不会被移动的内存。
为什么需要Pin指针 rfc中明确的概念是，提了一个使用futures(async/await)的例子：正在poll的future结构体，希望其能保存指向自己的引用。事实上我并没有明白其想表达的意思，但结合其他博文, 大致明白了需求的具体背景情形。
 实现async/await函数时，由于需要记录当前所处的状态(每次await的时候都会导致一个状态)，所以编译器往往生成的是一个匿名的enum，每个enum变体保存从外部或者之前的await点捕获的变量。
 在这篇文章的例子中，提到了await前的会被从stack中清理，await后能调用到被清理的数据是因为这些数据保存在了编译器生成的匿名enum，其充当了虚拟栈。如果await前有一个变量v，再有一个引用变量v的rv，那么这俩都会保存在这个匿名enum中，即这个enum发生了自引用的情景，也是pin指针要发挥作用的情景。
题外？为什么是pin指针？ rfc中提到了解决自引用的另外有趣的办法。他们想设计一个名为move或?move的trait，只有实现这个trait的类型才有搬家的权力或者被禁止搬家。但是他们认为会带来使得一些API无法向后兼容的改变，或者或者因为过于灵活带来隐患。但这些个人认为或许在语言发展到一定程度后才能看出那个更优，而现在则感觉rust会加入太多的指针（丢人的表示写了后面忘了前面，预定一个指针总结笔记）,所以毒奶一口会在rust2中回归（x
参考资料:
 Pin概念解析 rust rfc 2349 The Why, What, and How of Pinning in Rust //需要复习  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.explosion.zip/posts/clash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.explosion.zip/posts/clash/</guid>
      <description>route add default gw 192.168.1.105 ens192</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.explosion.zip/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.explosion.zip/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>APFS开启透明压缩</title>
      <link>https://blog.explosion.zip/posts/apfs%E5%BC%80%E5%90%AF%E9%80%8F%E6%98%8E%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.explosion.zip/posts/apfs%E5%BC%80%E5%90%AF%E9%80%8F%E6%98%8E%E5%8E%8B%E7%BC%A9/</guid>
      <description>brew install afsctool afsctool -c -j8 **** #要压缩的目录 j是开启几个线程,m系列乞丐u就是4大4小,所以选了8. 我压缩的用户空间,主要是代码,干掉了10个g.
https://apple.stackexchange.com/questions/360120/apfs-how-do-i-enable-transparent-compression
感谢土豆!</description>
    </item>
    
  </channel>
</rss>
