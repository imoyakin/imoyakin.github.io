---
title: "Solana为什么快"
date: 2022-08-11T13:26:57+08:00
draft: true
---

# solana为什么能追上香港记者

相比于bitcoin每秒只能处理大概10次交易(transactions per second, TPS)的性能, 基于pBFT的PoS系统可以在100-200个节点中支持到1000TPS.而solana,这个类PBFT的PoS链,可以在超过200个节点的情况下提供超过50,000TPS的性能.

在我个人的实际性能测试中,单个节点的solana,在i7-8086k和nv A2000(开启CUDA)以及970 SSD的性能基础上,得到了峰值60,000,均值30,000的性能水平.官方提到的超过50,000的性能,应该是指在其推荐的配置下跑出---(更多核心的AMD zen3线程撕裂者, 合理配置的SSD, 以及各个节点间网络速度超过300M). 实际上,在solana官方另一个宣传视频中,40Gbps的网络保证下跑到了710,000的TPS.

solana为什么能提供如此高的TPS性能?solana官方讲解了其认为对提高性能有所帮助的如下八大创新:

Proof of History (POH) — a clock before consensus;
Tower BFT — a PoH-optimized version of PBFT;
Turbine — a block propagation protocol;
Gulf Stream — Mempool-less transaction forwarding protocol;
Sealevel — Parallel smart contracts run-time;
Pipelining — a Transaction Processing Unit for validation optimization
Cloudbreak — Horizontally-Scaled Accounts Database; and
Archivers — Distributed ledger storage

这里展开讨论:

## Proof of History (POH) 
区块链网络作为一个整体与需要与单个节点的性能匹配,这意味着带宽不能称为瓶颈,而是节点的计算能力.为了实现这点,区块链网络需要优化各个节点中的通信方式.

文章中提到,手机的蜂窝网络信号和区块链网络遇到的问题十分类似: 没有一个信号塔能做到提供足够的带宽给每个手机提供无线电频率,所以电信公司引入了一个名叫时多分址(TDMA)的技术. 该技术的核心是,允许不同用户的手机在不通的时间片内使用相同的频率.用户迅速的传输,一个接着一个,以此让一个基站同时连接多个手机.
这就意味着信号站要提供一个全球可用的时钟,eth也是同理. eth借由准确的时间戳来帮助所有的节点通信.可惜的是,当前的eth每15秒产生一个区块,而每个区块容纳的信息量是有限的.这天然的限制了eth可以达到的tps性能.

solana的一个核心是PoH(历史证明),这是一个全球可用的、无权限的网络时间源,不需要网络当前的PoS共识达成即可使用.也就是说,PoH实质上是一个时间解决方案.

每个solana验证者通过类似VDF的机制将流逝的时间用串行编码为一个个简单的sha256. solana规定了每隔一段sha256计算工作为一个纪元,被异步/提前决定的领导者(是不是有一种钦定的感觉?)会被在纪元内轮换,与此同时,每一个验证器都通过运行VDF来维护自己的时钟.在这个设计下,网络不会等待任何失败或错误的节点,且无论网络条件如何,整个网络都会继续向前迭代.且网络在轮换验证者的时候没有发生任何相关的沟通.

这样的核心设计,除了提供一个可以用于时间戳的时钟外, 还允许solana优化区块的时间(比如公链当前为800ms), 简化区块传播(log200(n)),提高吞吐量.
而在块大小被限制的情况下,越频繁的出块,就意味着可承载的交易量越高.

## Tower BFT



## Turbine

solana的Turbin技术是大量借鉴了bittorrent数据传输技术. 当需要传播一个块时, solana选择将其拆解成包含了ec码的细碎小块,然后发送给随机的一大群其他对等节点.假设传播给200个对等节点,那么下一层就可以传播`200^2` = 40,000个节点.这就代表了传播传播难度是log200(n).如果每次建立连接耗时100ms,复制需要消耗400ms,那么对于40,000个节点的网络来说,500ms就能完成全部的复制.


## Gulf Stream

在一个高性能的网络中，mempool管理是一类新的问题，其他链并没有真正需要解决。湾流的功能是将交易缓存和转发推到网络的边缘。由于每个验证者都知道Solana架构中即将到来的领导者的顺序，客户和验证者提前将交易转发给预期的领导者。这使得验证者可以提前执行交易，减少确认时间，更快地切换领导者，并减少未确认交易池对验证者的内存压力。

客户端，如钱包，签署引用特定区块哈希的交易。客户端选择一个相当新的、已经被网络完全确认的区块链。区块大约每800ms提出一次，每增加一个区块都需要指数级增加的超时来避免回滚。使用我们默认的超时曲线，在最坏的情况下，一个完全确认的区块哈希，将是最新区块的32个之前的区块。假设区块时间为800毫秒，这相当于25.6秒。

一旦一个交易被转发到任何验证器，验证器就会将其转发到即将到来的领导者之一。客户端可以订阅来自验证者的交易确认。客户端会知道区块哈希在有限的时间内过期，或者交易被网络确认。这允许客户签署交易，保证执行或失败。一旦网络过了回滚点，使交易引用的区块哈希已经过期，客户就可以确保交易现在是无效的，永远不会在链上执行。

## Sealevel
Sealevel，一个平行化的交易处理引擎，旨在跨GPU和SSD进行水平扩展。请注意，所有其他区块链都是单线程的计算机。Solana是唯一一个支持单分片中并行交易执行（不仅仅是签名验证）的链。

这个问题的解决方案在很大程度上借用了操作系统的驱动技术，称为散点收集。事务在前面指定了它们在执行时要读和写什么状态。运行时能够找到一个区块中发生的所有非重叠的状态转换功能，并 并行地执行它们--这就是所谓的并行执行--同时优化如何在RAID 0 SSD阵列中安排对状态的读写。

虽然Sealevel本身是一个调度事务的虚拟机，但Sealevel实际上并没有在虚拟机中执行事务。相反，Sealevel把事务交给硬件来执行，使用的是业界公认的字节码，称为伯克利包过滤器（BPF），它是为高性能包过滤器设计的。这个字节码从90年代初就开始优化，并在全球数百万台交换机中进行了生产部署，在一台40G的网络中，每秒可处理6000万个数据包。

每当Nvidia将可用的SIMD通道数量增加一倍，solana的网络的计算能力就会增加一倍。几乎所有其他区块链，在设计上都是单线程的计算机，永远无法以这种方式扩展。

使用LLVM，也就是针对WASM的编译器，solana为开发者提供了一套很好的工具，用C/C++和Rust编写高性能的智能合约，在GPU上执行合约。虽然Solana没有使用WASM，但开发者可以在Solana编译器中重新编译为WASM编译器编写的C和Rust代码，只需最小的改动。因此，开发人员可以很容易地从其他主要的WASM链上迁移他们的应用程序，如Dfinity、EOS、Polkadot和Ethereum 2.0。

写出安全的Solidity代码绝对是可能的，就像用C语言写出没有内存保护的复杂软件是可能的。但是，只要不安全的行为很容易被添加，而很难被发现，那么验证复杂软件的行为就会变得几何般困难。Solana和Libra团队很早就认识到了这个问题，并开发了在不同模块之间保持严格状态分离的架构。

Move语言引入了资源和脚本作为高级概念。两者都很自然地融入了Solana的Sealevel Runtime，以及我们一直在设计我们的本地程序的方式。我们的目标是支持Move作为第一级语言，使资源表现为本地的Solana程序，并且可以通过Move或我们自己的本地Rust ABI进行开发和组成，而不会对性能或安全性造成任何影响。

实际上目前已经有个提案被接受,那就是让sealvel支持diem(facebook 的libra是其前身)上合约的move语言.

## Pipelining

在Solana网络上的交易验证过程中，广泛使用了CPU设计中常见的一种优化方法，称为流水线。当有一个输入数据流需要通过一系列的步骤进行处理，并且有不同的硬件负责每一个步骤时，流水线是合适的过程。

在Solana网络上，流水线机制--交易处理单元--在内核层面通过数据获取，在GPU层面通过签名验证，在CPU层面通过打包业务，在内核空间通过写入。当TPU开始向验证者发送数据块时，它已经获取了下一组数据包，验证了它们的签名，并开始计入代币。

在这个四级管道的GPU并行化之间，在任何特定时刻，Solana TPU可以同时在50,000个交易上取得进展。这一切都可以通过一台低于5000美元的现成计算机来实现。随着GPU卸载到Solana的交易处理单元上，网络可以影响单节点效率

## Cloudbreak 横向扩展内存
solana官方认为仅仅扩展计算是不够的，用于跟踪账户的内存在 大小 和 访问速度 上会迅速成为瓶颈。现在人们普遍的认为levelDB不能提供超过大约5000TPS。

一个天真的解决方案是在RAM中维护全局状态，然而期望在消费级机器中提供足够的RAM来存储这些状态是不合理的。solana通过设计软件，充分利用SSD在raid0上的配置来实现并发读写的优化。

与solana的交易设计相结合，其支持交易的AOT(提前编译?)执行。一但验证器观察到一个交易，sealevel就可以开始从磁盘上预取所有的账户，并为执行做好准备。区块生产者和验证者可以在交易被编码成区块之前就开始执行交易，这使得整个网络可以进一步优化区块时间和确认延迟。

## Archivers 归档者
在1Gbps的网络下，区块链网络将会产生4PB的数据。储存数据将会成为主要的集中化载体，这个过程违背了区块链实施的根本目的。

在solana上，数据存储被从验证者哪里卸载到了一个叫做存档者的节点网络上。存档者不参与公式。状态的历史被分解为许多碎片，并进行EC编码。存档者只存储状态的一小部分，同时每隔一段时间，网络会要求存档者证明他们正在正确的存储他们应当存储的数据。solana利用了复制证明（PoRep），这是从filecoin中所被借用来的概念。

我们能够使用历史证明--我们在共识之前的时钟--来优化PoReps的创建方式。不参与共识的Archiver节点使用PoH生成轻量级的证明，通过这些证明，账本的各个部分已经被复制，验证者能够在GPU上大批量地验证它们。

归档者可以是轻量级节点（如笔记本电脑）。通过擦除代码和冗余，存档者网络可以提供数据可用性保证，超过AWS或GCE所能提供的任何东西。
归档者可以

## 参考
1. [8 Innovations that Make Solana the First Web-Scale Blockchain](https://medium.com/solana-labs/7-innovations-that-make-solana-the-first-web-scale-blockchain-ddc50b1defda)